{
  "gemini_analysis": "RELEVANT FILES:\n- `src/gitingest/cli.py`\n- `src/gitingest/entrypoint.py`\n- `src/gitingest/ingestion.py`\n- `src/gitingest/query_parsing.py`\n- `src/gitingest/cloning.py`\n- `src/server/routers/index.py`\n- `src/server/query_processor.py`\n- `src/static/js/utils.js`\n- `tests/test_cli.py`\n- `tests/test_ingestion.py`\n- `tests/test_flow_integration.py`\n- `tests/test_query_parser.py`\n- `.github/workflows/ci.yml`\n- `.github/workflows/publish.yml`\n\nKEY CODE ELEMENTS:\n```filename: src/gitingest/cli.py\n@click.command()\n@click.argument(\"source\")\n@click.option(\n    \"--output\",\n    \"-o\",\n    type=click.Path(exists=False, writable=True, path_type=Path),\n    default=None,\n    help=\"Output file path. If not specified, prints to stdout.\",\n)\n@click.option(\n    \"--max-size\",\n    \"-m\",\n    type=int,\n    default=None,\n    help=\"Maximum file size to ingest (in KB). Defaults to no limit.\",\n)\n@click.option(\n    \"--exclude-pattern\",\n    \"-e\",\n    multiple=True,\n    help=\"Exclude files matching this pattern. Can be specified multiple times.\",\n)\n@click.option(\n    \"--include-pattern\",\n    \"-i\",\n    multiple=True,\n    help=\"Include files matching this pattern. Can be specified multiple times.\",\n)\n@click.option(\n    \"--branch\",\n    \"-b\",\n    type=str,\n    default=None,\n    help=\"The specific branch to use. Defaults to the repository's main branch.\",\n)\n@asyncio_run\nasync def gitingest(\n    source: str,\n    output: Path | None,\n    max_size: int | None,\n    exclude_pattern: tuple[str, ...],\n    include_pattern: tuple[str, ...],\n    branch: str | None,\n) -> None:\n    \"\"\"\n    Ingests a repository or directory, clones it if needed, then returns the\n    directory structure and all file contents (up to the max size limit).\n    \"\"\"\n    results = await ingest_async(source, max_size, list(exclude_pattern), list(include_pattern), branch)\n\n    if output:\n        output.write_text(results.formatted_content)\n    else:\n        print(results.formatted_content)\n```\n\n```filename: src/gitingest/entrypoint.py\nasync def ingest_async(\n    source: str,\n    max_size: int | None = None,\n    exclude_patterns: list[str] | None = None,\n    include_patterns: list[str] | None = None,\n    branch: str | None = None,\n) -> IngestedData:\n    \"\"\"Ingests a URL or local path. If a URL, it clones it, and then processes it.\"\"\"\n    query = parse_query(source, max_file_size_kb=max_size, include_patterns=include_patterns, ignore_patterns=exclude_patterns, branch=branch)\n    return await ingest_query(query)\n\ndef ingest(\n    source: str,\n    max_size: int | None = None,\n    exclude_patterns: list[str] | None = None,\n    include_patterns: list[str] | None = None,\n    branch: str | None = None,\n) -> IngestedData:\n    \"\"\"Synchronous wrapper for ingest_async.\"\"\"\n    return asyncio.run(ingest_async(source, max_size, exclude_patterns, include_patterns, branch))\n```\n\n```filename: src/server/routers/index.py\n@router.post(\"/\")\nasync def process_git(\n    request: Request,\n    input_text: str = Form(...),\n    slider_position: int = Form(500),\n    pattern_type: str = Form(\"\"),\n    pattern: str = Form(\"\"),\n    is_index: bool = True,\n):\n    \"\"\"Processes a git repository URL and renders the result.\"\"\"\n    return await process_query(request, input_text, slider_position, pattern_type, pattern, is_index)\n```\n\n```filename: src/server/query_processor.py\nasync def process_query(request: Request, input_text: str, slider_position: int, pattern_type: str, pattern: str, is_index: bool):\n    try:\n        max_file_size_kb = log_slider_to_size(slider_position)\n\n        query = parse_query(\n            input_text,\n            max_file_size_kb=max_file_size_kb,\n            include_patterns=[pattern] if pattern_type == \"include\" and pattern else None,\n            ignore_patterns=[pattern] if pattern_type == \"exclude\" and pattern else None,\n        )\n\n        clone_config = query.extract_clone_config()\n        await clone_repo(clone_config)\n\n        results = await ingest_query(query)\n\n        content_display = results.formatted_content[:server_config.MAX_DISPLAY_SIZE]\n\n        # Render the template with the results\n        return templates.TemplateResponse(\n            \"index.jinja\" if is_index else \"git.jinja\",\n            {\n                \"request\": request,\n                \"summary\": results.summary,\n                \"directory_structure\": results.directory_structure,\n                \"content\": content_display,\n                \"input_text\": input_text,\n                \"is_index\": is_index,\n            },\n        )\n    except Exception as e:\n        tb_str = traceback.format_exception(type(e), e, e.__traceback__)\n        error_message = f\"Error processing the repository: {e}\\n{''.join(tb_str)}\"\n        return templates.TemplateResponse(\n            \"index.jinja\" if is_index else \"git.jinja\",\n            {\n                \"request\": request,\n                \"error\": error_message,\n                \"input_text\": input_text,\n                \"is_index\": is_index,\n            },\n        )\n```\n\n```filename: src/static/js/utils.js\nfunction handleSubmit(event, showLoading = false) {\n    event.preventDefault();\n\n    const form = event.target;\n    const formData = new FormData(form);\n\n    // Get the file size limit from the slider\n    const sliderPosition = document.getElementById('fileSizeSlider').value;\n    const fileSizeInKB = logSliderToSize(sliderPosition);\n    formData.set('slider_position', sliderPosition);\n\n    // Get pattern type\n    var patternType = document.querySelector('input[name=\"patternType\"]:checked');\n    if (patternType) {\n        patternType = patternType.value\n    } else {\n        patternType = \"\";\n    }\n    formData.set('pattern_type', patternType);\n\n    // Get pattern\n    const pattern = document.getElementById('pattern').value;\n    formData.set('pattern', pattern);\n\n    // Show loading animation on submit button\n    const submitButton = form.querySelector('button[type=\"submit\"]');\n    if (showLoading) {\n        submitButton.innerHTML = '<span class=\"spinner-border spinner-border-sm\" role=\"status\" aria-hidden=\"true\"></span> Loading...';\n        submitButton.disabled = true;\n    }\n\n    fetch(form.action, {\n        method: form.method,\n        body: formData\n    })\n    .then(response => response.text())\n    .then(html => {\n        // Replace the entire page content with the response from the server\n        document.documentElement.innerHTML = html;\n\n        // Re-init the slider\n        initializeSlider();\n        // Handle scrolling to results after the content is replaced\n        const resultsDiv = document.getElementById('results');\n        if (resultsDiv) {\n            resultsDiv.scrollIntoView({ behavior: 'smooth' });\n        }\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        // Re-enable the submit button and remove the loading animation\n        submitButton.innerHTML = 'Submit';\n        submitButton.disabled = false;\n    });\n}\n```\n\n**Consolidated Analysis:**\n\nThe `gitingest` repository offers both a command-line interface and a web application to ingest and analyze code from Git repositories (or local directories). The core functionality involves parsing the input source, cloning the repository (if necessary), traversing the file system, filtering files based on include/exclude patterns and size limits, extracting content, and formatting the output.\n\n**Key Components:**\n\n*   **CLI (`src/gitingest/cli.py`):**  Uses `click` to provide a command-line interface for ingesting code. The `gitingest` command accepts arguments for the source (URL or local path), output file, max file size, exclude patterns, include patterns, and branch.\n\n*   **Ingestion Engine (`src/gitingest/entrypoint.py`, `src/gitingest/ingestion.py`, `src/gitingest/query_parsing.py`, `src/gitingest/cloning.py`):** This is the core logic for parsing the input, cloning the repo, traversing the file system, extracting content, and formatting the output.  `ingest_async` is the main entry point for ingestion. `parse_query` parses the URL/path and creates an `IngestionQuery` object.  `clone_repo` clones the repo using the `CloneConfig`. `ingest_query` handles the actual processing.\n\n*   **Web Server (`src/server/routers/index.py`, `src/server/query_processor.py`):** A FastAPI-based web server that provides a web interface for submitting Git repository URLs and analyzing their contents. `index.py` handles routing and calls the `process_query` to perform the actual ingestion and rendering. `process_query` orchestrates the parsing, cloning, ingestion, and rendering processes.\n\n*   **Frontend (`src/static/js/utils.js`):** JavaScript code that handles form submissions, UI updates, and copying text to the clipboard. The `handleSubmit` function manages form submission and page updates based on the server's response. The javascript implements the slider functionality.\n\n*   **Testing (`tests/test_cli.py`, `tests/test_ingestion.py`, `tests/test_query_parser.py`, `tests/test_flow_integration.py`):** A comprehensive suite of tests that cover the CLI, core ingestion logic, query parsing, and end-to-end flow. The integration tests verify that the frontend and backend interact correctly.\n\n*   **CI/CD (`.github/workflows/ci.yml`, `.github/workflows/publish.yml`):**  GitHub Actions workflows for Continuous Integration (running tests and linting on pull requests) and Continuous Deployment (publishing the package to PyPI on new releases).\n**Key Files, Functions, Classes, Components, Frontend, Backend, and Database files:**\n\n*   **RELEVANT FILES:** See beginning of response\n*   **KEY CODE ELEMENTS:** See beginning of response\n*   **Key Files**\n    *   **`cli.py`:** Command-line interface.\n    *   **`entrypoint.py`, `ingestion.py`, `query_parsing.py`, `cloning.py`:** Core ingestion engine files.\n    *   **`index.py`, `query_processor.py`:** Web server route and core processor.\n    *   **`utils.js`:** Client-side javascript utilities.\n*   **Functions:**\n    *   **`ingest_async(source)` (entrypoint.py):** Main entry point for ingestion.\n    *   **`parse_query(source)` (query_parsing.py):** Parses the input source.\n    *   **`clone_repo(config)` (cloning.py):** Clones a Git repository.\n    *   **`handleSubmit(event)` (utils.js):** Handles form submission on the frontend.\n    *   **`process_query(request, input_text, slider_position, pattern_type, pattern, is_index)` (query_processor.py)**: Core server backend function.\n*   **Classes/Data Structures:**\n    *   `IngestionQuery`: Dataclass/Pydantic model holding parsed query parameters.\n    *   `CloneConfig`: Dataclass holding cloning configuration.\n*   **Components:**\n    *   **CLI:** Command-line interface.\n    *   **Web Server:** FastAPI-based web server.\n    *   **Ingestion Engine:** Core logic for processing codebases.\n    *   **Frontend:** JavaScript-based user interface.\n*   **Frontend:** `src/static/js/utils.js`, Jinja2 templates (`src/server/templates/`)\n*   **Backend:** `src/gitingest/*`, `src/server/*`\n*   **Database files:** Not explicitly used. Temporary directories are utilized for cloning the code, but those are removed. The processed \"digest\" is returned to the user or written to an output file; persistence is not explicitly incorporated.\n",
  "groq_summary": "### Detailed Summary of Extracted Files\n\nThe provided repository contains various files that contribute to the functionality of a Git repository ingestion and analysis tool. Below is a detailed summary of each file:\n\n#### 1. `src/gitingest/cli.py`\n\n*   This file defines the command-line interface (CLI) for the ingestion tool using the Click library.\n*   The `gitingest` command accepts arguments for the source (URL or local path), output file, max file size, exclude patterns, include patterns, and branch.\n*   The `gitingest` function is the main entry point for the CLI, which calls the `ingest_async` function to perform the ingestion.\n\n#### 2. `src/gitingest/entrypoint.py`\n\n*   This file contains the core logic for ingesting a Git repository or directory.\n*   The `ingest_async` function is the main entry point for ingestion, which parses the input source, clones the repository (if necessary), and processes the files.\n*   The `ingest` function is a synchronous wrapper for `ingest_async`.\n\n#### 3. `src/gitingest/ingestion.py`\n\n*   Although not provided, this file is likely responsible for the actual ingestion of files, including traversing the file system, filtering files based on include/exclude patterns and size limits, and extracting content.\n\n#### 4. `src/gitingest/query_parsing.py`\n\n*   Although not provided, this file is likely responsible for parsing the input source and creating an `IngestionQuery` object.\n*   The `parse_query` function is used to parse the input source and create an `IngestionQuery` object.\n\n#### 5. `src/gitingest/cloning.py`\n\n*   Although not provided, this file is likely responsible for cloning a Git repository.\n*   The `clone_repo` function is used to clone a Git repository using the `CloneConfig`.\n\n#### 6. `src/server/routers/index.py`\n\n*   This file defines the routing for the web server using FastAPI.\n*   The `process_git` function handles the processing of a Git repository URL and renders the result.\n\n#### 7. `src/server/query_processor.py`\n\n*   This file contains the core logic for processing a Git repository query.\n*   The `process_query` function orchestrates the parsing, cloning, ingestion, and rendering processes.\n*   It also handles errors and exceptions during the processing.\n\n#### 8. `src/static/js/utils.js`\n\n*   This file contains JavaScript code that handles form submissions, UI updates, and copying text to the clipboard.\n*   The `handleSubmit` function manages form submission and page updates based on the server's response.\n\n#### 9. `tests/test_cli.py`\n\n*   This file contains tests for the command-line interface (CLI).\n*   The tests verify that the CLI functions correctly and handles different scenarios.\n\n#### 10. `tests/test_ingestion.py`\n\n*   This file contains tests for the ingestion logic.\n*   The tests verify that the ingestion functions correctly and handles different scenarios.\n\n#### 11. `tests/test_flow_integration.py`\n\n*   This file contains tests for the end-to-end flow of the application.\n*   The tests verify that the application functions correctly from the user's perspective.\n\n#### 12. `tests/test_query_parser.py`\n\n*   This file contains tests for the query parsing logic.\n*   The tests verify that the query parser functions correctly and handles different scenarios.\n\n#### 13. `.github/workflows/ci.yml`\n\n*   This file defines a GitHub Actions workflow for continuous integration (CI).\n*   The workflow runs tests and linting on pull requests.\n\n#### 14. `.github/workflows/publish.yml`\n\n*   This file defines a GitHub Actions workflow for continuous deployment (CD).\n*   The workflow publishes the package to PyPI on new releases.\n\n### Key Components and Technologies\n\n*   **Command-Line Interface (CLI):** The application provides a CLI for ingesting Git repositories or directories.\n*   **Web Server:** The application uses FastAPI to provide a web interface for ingesting Git repositories.\n*   **Ingestion Engine:** The application uses a core ingestion engine to process Git repositories or directories.\n*   **Frontend:** The application uses JavaScript and HTML/CSS to provide a user interface.\n*   **Backend:** The application uses Python and FastAPI to provide a web server and ingestion engine.\n*   **Database:** The application does not use a database explicitly, but it uses temporary directories for cloning and processing Git repositories.\n\n### Example Use Cases\n\n*   **Command-Line Interface (CLI):** A user can use the CLI to ingest a Git repository or directory by running the command `gitingest <source> --output <output_file>`.\n*   **Web Interface:** A user can use the web interface to ingest a Git repository by entering the repository URL and clicking the \"Ingest\" button.\n*   **Integration with CI/CD Pipelines:** The application can be integrated with CI/CD pipelines to automate the ingestion and analysis of Git repositories.\n\n### Advice and Next Steps\n\n*   **Security:** Ensure that the application handles sensitive information, such as Git repository credentials, securely.\n*   **Error Handling:** Improve error handling and logging to provide better feedback to users.\n*   **Performance:** Optimize the ingestion engine to improve performance and handle large Git repositories.\n*   **Testing:** Add more tests to cover different scenarios and edge cases.\n*   **Documentation:** Improve documentation to provide better guidance to users and developers."
}